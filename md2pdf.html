<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MD2PDF 穩定輸出版</title>
    
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    
    <style>
        /* --- 基礎 UI --- */
        body { margin: 0; height: 100vh; display: flex; flex-direction: column; font-family: sans-serif; background: #333; }
        
        header { 
            height: 50px; background: #222; color: white; display: flex; align-items: center; justify-content: space-between; padding: 0 20px; 
        }

        .main { display: flex; flex: 1; overflow: hidden; }
        
        /* 編輯區 */
        .editor { width: 50%; height: 100%; border-right: 1px solid #444; }
        textarea { 
            width: 100%; height: 100%; border: none; padding: 20px; box-sizing: border-box; 
            resize: none; outline: none; font-family: monospace; font-size: 14px; 
        }

        /* 預覽區 (這裡是關鍵) */
        .preview { 
            width: 50%; height: 100%; background: #525659; overflow-y: auto; 
            display: flex; justify-content: center; padding: 20px; box-sizing: border-box;
        }

        /* A4 紙張本體 */
        #paper {
            background: white;
            width: 210mm; 
            min-height: 297mm;
            padding: 20mm;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            color: black;
            /* 讓內容撐開高度，不要設死 height */
        }

        /* --- 內容樣式 --- */
        table { width: 100%; border-collapse: collapse; margin: 15px 0; border: 2px solid #000; }
        th, td { border: 1px solid #666; padding: 8px; }
        img { max-width: 100%; }
        
        /* 防切斷 (分頁控制) */
        p, h1, h2, h3, li, table, pre, .math-protect { 
            page-break-inside: avoid; 
            break-inside: avoid; 
        }
        
        /* 下載時的狀態遮罩 */
        #status {
            position: fixed; bottom: 20px; right: 20px; 
            background: #27ae60; color: white; padding: 10px 20px; 
            border-radius: 5px; display: none; font-weight: bold;
        }
    </style>

    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$']] },
            svg: { fontCache: 'none' }, 
            startup: { typeset: false }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>

    <header>
        <div>MD2PDF (Debug版)</div>
        <button onclick="makePDF()" style="cursor:pointer; padding:5px 15px; font-size:14px;">下載 PDF</button>
    </header>

    <div class="main">
        <div class="editor">
            <textarea id="input" oninput="run()"># PDF 空白測試

請測試下載後是否有內容。

## 1. 列表測試
- 項目 A
- 項目 B

## 2. 表格測試
| ID | 數值 |
|:---|:---|
| 01 | 100 |
| 02 | 200 |

## 3. 公式測試
$$
x = \frac{-b \pm \sqrt{b^2-4ac}}{2a}
$$
            </textarea>
        </div>
        <div class="preview">
            <div id="paper"></div>
        </div>
    </div>

    <div id="status">正在生成 PDF...</div>

    <script>
        const input = document.getElementById('input');
        const paper = document.getElementById('paper');
        const status = document.getElementById('status');

        // --- 1. 基礎 Markdown 渲染 ---
        function run() {
            let md = input.value;
            
            // 簡單的數學公式保護 (避免 marked 吃掉 LaTeX)
            let cache = [];
            md = md.replace(/\$\$([\s\S]*?)\$\$/g, (m) => { cache.push(m); return `___MB${cache.length-1}___`; });
            md = md.replace(/\$([^\$\n]+?)\$/g, (m) => { cache.push(m); return `___MI${cache.length-1}___`; });

            let html = marked.parse(md);

            // 還原公式
            cache.forEach((tex, i) => {
                // 如果是區塊公式，加個 div 包起來 (防切斷用)
                const isBlock = tex.startsWith('$$');
                const tag = isBlock ? `<div class="math-protect">${tex}</div>` : tex;
                html = html.replace(`___MB${i}___`, tag).replace(`___MI${i}___`, tag);
            });

            paper.innerHTML = html;

            // 觸發 MathJax
            if(window.MathJax && window.MathJax.typesetPromise) {
                window.MathJax.typesetPromise([paper]);
            }
        }

        // 初始化
        setTimeout(run, 500);


        // --- 2. SVG 轉 圖片 (解決 LaTeX 跑版與空白問題) ---
        async function rasterizeMath() {
            const svgs = paper.querySelectorAll('svg');
            for (let svg of svgs) {
                try {
                    const rect = svg.getBoundingClientRect();
                    if (rect.width < 1 || rect.height < 1) continue;

                    const xml = new XMLSerializer().serializeToString(svg);
                    const canvas = document.createElement('canvas');
                    const scale = 3; 
                    canvas.width = rect.width * scale;
                    canvas.height = rect.height * scale;
                    
                    const img = new Image();
                    img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(xml)));
                    
                    await new Promise(r => img.onload = r);
                    
                    const ctx = canvas.getContext('2d');
                    ctx.scale(scale, scale);
                    ctx.drawImage(img, 0, 0);

                    const finalImg = document.createElement('img');
                    finalImg.src = canvas.toDataURL('image/png');
                    finalImg.style.width = rect.width + 'px';
                    finalImg.style.verticalAlign = 'middle';
                    
                    // 替換
                    const container = svg.parentNode;
                    if(container) {
                         container.parentNode.replaceChild(finalImg, container);
                    }
                } catch(e) { console.error(e); }
            }
        }

        // --- 3. 生成 PDF ---
        async function makePDF() {
            status.style.display = 'block';
            
            // A. 先把公式轉成圖片 (這是防止空白的關鍵)
            await rasterizeMath();

            // B. 直接對頁面上的 #paper 進行截圖
            // 不使用 clone，直接抓看得到的東西
            const opt = {
                margin: 0,
                filename: 'document.pdf',
                image: { type: 'jpeg', quality: 0.98 },
                html2canvas: { 
                    scale: 2, 
                    useCORS: true,
                    windowWidth: 1000 // 強制設定寬度，避免響應式佈局導致變形
                },
                jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' },
                pagebreak: { mode: ['avoid-all', 'css', 'legacy'] }
            };

            await html2pdf().set(opt).from(paper).save();
            
            status.style.display = 'none';
            
            // C. 為了讓使用者能繼續編輯，重新渲染一次 (恢復成可編輯的 SVG 狀態)
            run();
        }
    </script>
</body>
</html>
