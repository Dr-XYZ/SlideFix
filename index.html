<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Slide Photo 2 PDF</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; max-width: 800px; margin: 0 auto; padding: 15px; background: #f0f2f5; color: #333; }
        .container { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        h1 { text-align: center; font-size: 1.4rem; margin-bottom: 20px; color: #2c3e50; }
        
        /* æ§åˆ¶å€ */
        .controls { text-align: center; padding: 20px; border: 2px dashed #cbd5e0; border-radius: 8px; background: #f8fafc; margin-bottom: 20px;}
        
        /* æ»‘æ¡¿è¨­å®šå€ */
        .setting-group { margin: 15px 0; padding: 10px; background: #edf2f7; border-radius: 6px; text-align: left; }
        .setting-label { font-size: 14px; font-weight: bold; display: flex; justify-content: space-between; margin-bottom: 5px; }
        input[type=range] { width: 100%; cursor: pointer; }

        /* æŒ‰éˆ•ç¾¤çµ„ */
        .btn-group { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-top: 15px; }
        .btn { padding: 12px 20px; border-radius: 8px; border: none; font-size: 16px; cursor: pointer; font-weight: 500; transition: background 0.2s; text-decoration: none; display: inline-flex; align-items: center; justify-content: center; }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        
        .btn-primary { background: #3182ce; color: white; width: 100%; } /* è—è‰² */
        .btn-warning { background: #dd6b20; color: white; width: 100%; margin-top: 5px;} /* æ©˜è‰² (é‡æ–°æƒæ) */
        
        .btn-pdf { background: #e53e3e; color: white; flex: 1; min-width: 140px; } /* ç´…è‰² */
        .btn-share { background: #38a169; color: white; flex: 1; min-width: 140px; } /* ç¶ è‰² */

        /* é€²åº¦æ¢ */
        #progress-container { margin-bottom: 20px; display: none; }
        .progress-bar { width: 100%; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden; }
        .progress-fill { height: 100%; background: #4299e1; width: 0%; transition: width 0.3s ease; }
        #status-text { text-align: center; margin-top: 8px; font-size: 13px; color: #718096; }

        /* çµæœåˆ—è¡¨ */
        .gallery { display: flex; flex-direction: column; gap: 20px; margin-top: 20px; }
        .gallery-item { display: flex; flex-direction: column; background: white; border: 1px solid #e2e8f0; border-radius: 8px; overflow: hidden; }
        .img-wrapper { background: #000; min-height: 200px; display: flex; align-items: center; justify-content: center; }
        .gallery-item img { max-width: 100%; height: auto; display: block; }
        .item-info { padding: 10px; font-size: 14px; font-weight: bold; color: #4a5568; text-align: center; border-top: 1px solid #eee; }

        .hidden { display: none; }
        input[type="file"] { display: none; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>

<div class="container">
    <h1>ğŸ“¸ Slide Photo 2 PDF</h1>
    
    <div class="controls">
        <div class="setting-group">
            <div class="setting-label">
                <span>âœ‚ï¸ é‚Šç·£è£åˆ‡ç¨‹åº¦ (å»é™¤é»‘é‚Š)</span>
                <span id="cropValue">3%</span>
            </div>
            <input type="range" id="cropInput" min="0" max="15" step="1" value="3" oninput="updateCropLabel(this.value)">
            <div style="font-size: 12px; color: #666; margin-top: 5px;">æ•¸å€¼è¶Šå¤§ï¼Œå¾€å…§åˆ‡è¶Šå¤š (å»ºè­° 2-5%)</div>
        </div>

        <input type="file" id="fileInput" accept="image/*" multiple disabled>
        
        <button class="btn btn-primary" id="selectBtn" onclick="document.getElementById('fileInput').click()" disabled>
            ğŸ“‚ é¸æ“‡ç…§ç‰‡
        </button>
        
        <button class="btn btn-warning hidden" id="rescanBtn" onclick="rescanImages()">
            ğŸ”„ å¥—ç”¨æ–°è¨­å®šä¸¦é‡æ–°æƒæ
        </button>

        <div id="status" style="margin-top:10px; font-size: 14px; color: #888;">â³ æ­£åœ¨è¼‰å…¥æ ¸å¿ƒ...</div>

        <div id="action-buttons" class="btn-group hidden">
            <button class="btn btn-pdf" id="btnPdf" onclick="downloadPDF()">ğŸ“„ ä¸‹è¼‰ PDF</button>
            <button class="btn btn-share" id="btnShare" onclick="shareAllImages()">ğŸ“¤ å„²å­˜æ‰€æœ‰åœ–ç‰‡</button>
        </div>
    </div>

    <div id="progress-container">
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div id="status-text">æº–å‚™ä¸­...</div>
    </div>

    <div class="gallery" id="gallery"></div>
</div>

<canvas id="processCanvas" class="hidden"></canvas>
<script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady()" type="text/javascript"></script>

<script>
    let cvReady = false;
    const MAX_DIMENSION = 2000;
    const TARGET_RATIO = 4.0 / 3.0; 
    let processedFiles = []; 

    function updateCropLabel(val) {
        document.getElementById('cropValue').innerText = val + "%";
    }

    function onOpenCvReady() {
        cvReady = true;
        document.getElementById('status').innerText = "âœ… ç³»çµ±å°±ç·’";
        document.getElementById('fileInput').disabled = false;
        document.getElementById('selectBtn').disabled = false;
    }

    // ç›£è½æª”æ¡ˆé¸æ“‡
    document.getElementById('fileInput').addEventListener('change', async (e) => {
        startProcessing();
    });

    // æ–°å¢ï¼šé‡æ–°æƒæå‡½å¼
    function rescanImages() {
        const fileInput = document.getElementById('fileInput');
        if (!fileInput.files || fileInput.files.length === 0) {
            alert("ç›®å‰æ²’æœ‰å·²è¼‰å…¥çš„ç…§ç‰‡ï¼");
            return;
        }
        startProcessing();
    }

    // å°‡è™•ç†é‚è¼¯æŠ½å–å‡ºä¾†
    async function startProcessing() {
        if (!cvReady) return;
        const fileInput = document.getElementById('fileInput');
        const files = Array.from(fileInput.files);
        
        if (files.length === 0) return;

        // å–å¾—ç›®å‰çš„è£åˆ‡å€¼
        const cropPercent = parseInt(document.getElementById('cropInput').value) / 100;

        // é‡ç½® UI
        document.getElementById('gallery').innerHTML = '';
        document.getElementById('action-buttons').classList.add('hidden');
        document.getElementById('progress-container').style.display = 'block';
        
        // é¡¯ç¤ºé‡æ–°æƒææŒ‰éˆ• (å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡åŸ·è¡Œï¼Œé€™è¡Œæœƒè®“æŒ‰éˆ•è·‘å‡ºä¾†)
        document.getElementById('rescanBtn').classList.remove('hidden');
        
        processedFiles = []; 
        
        await processBatch(files, cropPercent);
    }

    async function processBatch(files, cropPercent) {
        const total = files.length;
        const statusText = document.getElementById('status-text');
        const progressFill = document.getElementById('progressFill');

        // æš«æ™‚åœç”¨æŒ‰éˆ•é¿å…é‡è¤‡é»æ“Š
        document.getElementById('selectBtn').disabled = true;
        document.getElementById('rescanBtn').disabled = true;

        for (let i = 0; i < total; i++) {
            const file = files[i];
            statusText.innerText = `æ­£åœ¨è™•ç† (${i + 1}/${total}): ${file.name}`;
            progressFill.style.width = `${((i + 1) / total) * 100}%`;

            try {
                const blob = await processSingleImage(file, cropPercent);
                if (blob) {
                    processedFiles.push({
                        blob: blob,
                        name: `fixed_${i+1}_${file.name}`,
                        originalName: file.name
                    });
                    addResultToPage(blob, file.name);
                }
            } catch (err) {
                console.error(`Error processing ${file.name}`, err);
            }
            await new Promise(resolve => requestAnimationFrame(resolve));
        }

        statusText.innerText = "ğŸ‰ è™•ç†å®Œæˆï¼";
        document.getElementById('action-buttons').classList.remove('hidden');
        
        // æ¢å¾©æŒ‰éˆ•
        document.getElementById('selectBtn').disabled = false;
        document.getElementById('rescanBtn').disabled = false;
    }

    function processSingleImage(file, cropPercent) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                try {
                    let src = cv.imread(img);
                    if (src.cols > MAX_DIMENSION || src.rows > MAX_DIMENSION) {
                        let scale = MAX_DIMENSION / Math.max(src.cols, src.rows);
                        cv.resize(src, src, new cv.Size(Math.round(src.cols * scale), Math.round(src.rows * scale)), 0, 0, cv.INTER_AREA);
                    }

                    let dst = new cv.Mat();
                    let gray = new cv.Mat();
                    let blurred = new cv.Mat();
                    let edged = new cv.Mat();
                    let dilated = new cv.Mat();
                    
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                    cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);
                    cv.Canny(blurred, edged, 50, 200);

                    let M = cv.Mat.ones(5, 5, cv.CV_8U);
                    let anchor = new cv.Point(-1, -1);
                    cv.dilate(edged, dilated, M, anchor, 2, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());

                    let contours = new cv.MatVector();
                    let hierarchy = new cv.Mat();
                    cv.findContours(dilated, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                    let maxArea = 0;
                    let bestContour = null;
                    let imageArea = src.cols * src.rows;

                    for (let i = 0; i < contours.size(); ++i) {
                        let cnt = contours.get(i);
                        let area = cv.contourArea(cnt);
                        if (area < imageArea * 0.1) continue;
                        let peri = cv.arcLength(cnt, true);
                        let approx = new cv.Mat();
                        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
                        if (approx.rows === 4) {
                            if (area > maxArea) {
                                maxArea = area;
                                if (bestContour) bestContour.delete();
                                bestContour = approx.clone();
                            }
                        }
                        approx.delete();
                    }

                    if (bestContour) {
                        warpPerspective(src, bestContour, dst, cropPercent);
                        bestContour.delete();
                    } else {
                        dst = src.clone();
                    }

                    cv.imshow('processCanvas', dst);
                    let canvas = document.getElementById('processCanvas');
                    canvas.toBlob((blob) => {
                        src.delete(); dst.delete(); gray.delete();
                        blurred.delete(); edged.delete(); dilated.delete();
                        contours.delete(); hierarchy.delete(); M.delete();
                        resolve(blob);
                    }, 'image/jpeg', 0.85);

                } catch (e) {
                    reject(e);
                }
            };
            img.src = URL.createObjectURL(file);
        });
    }

    function warpPerspective(src, contour, dst, cropPercent) {
        let pts = [];
        for (let i = 0; i < 4; i++) {
            pts.push(contour.data32S[i * 2]);
            pts.push(contour.data32S[i * 2 + 1]);
        }
        let sortedPts = orderPoints(pts);

        if (cropPercent > 0) {
            sortedPts = shrinkRect(sortedPts, cropPercent);
        }

        let tl = sortedPts[0], tr = sortedPts[1], br = sortedPts[2], bl = sortedPts[3];
        let widthA = Math.hypot(br.x - bl.x, br.y - bl.y);
        let widthB = Math.hypot(tr.x - tl.x, tr.y - tl.y);
        let maxWidth = Math.max(widthA, widthB);
        let finalWidth = maxWidth;
        let finalHeight = Math.floor(finalWidth / TARGET_RATIO);

        let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [tl.x, tl.y, tr.x, tr.y, br.x, br.y, bl.x, bl.y]);
        let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, finalWidth, 0, finalWidth, finalHeight, 0, finalHeight]);
        
        let transformM = cv.getPerspectiveTransform(srcTri, dstTri);
        cv.warpPerspective(src, dst, transformM, new cv.Size(finalWidth, finalHeight), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
        
        srcTri.delete(); dstTri.delete(); transformM.delete();
    }

    function shrinkRect(pts, percentage) {
        let cx = (pts[0].x + pts[1].x + pts[2].x + pts[3].x) / 4;
        let cy = (pts[0].y + pts[1].y + pts[2].y + pts[3].y) / 4;
        return pts.map(p => {
            return {
                x: cx + (p.x - cx) * (1 - percentage),
                y: cy + (p.y - cy) * (1 - percentage)
            };
        });
    }

    function orderPoints(pts) {
        let points = [{x: pts[0], y: pts[1]}, {x: pts[2], y: pts[3]}, {x: pts[4], y: pts[5]}, {x: pts[6], y: pts[7]}];
        points.sort((a, b) => (a.x + a.y) - (b.x + b.y));
        let tl = points[0], br = points[3];
        let remaining = [points[1], points[2]];
        remaining.sort((a, b) => (a.y - a.x) - (b.y - b.x));
        return [tl, remaining[0], br, remaining[1]];
    }

    function addResultToPage(blob, originalName) {
        const url = URL.createObjectURL(blob);
        const div = document.createElement('div');
        div.className = 'gallery-item';
        div.innerHTML = `
            <div class="img-wrapper"><img src="${url}"></div>
            <div class="item-info">å·²è™•ç†: ${originalName}</div>
        `;
        document.getElementById('gallery').appendChild(div);
    }

    async function downloadPDF() {
        if (processedFiles.length === 0) return;
        const btn = document.getElementById('btnPdf');
        btn.disabled = true;
        btn.innerText = "æ­£åœ¨è£½ä½œ PDF...";

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ orientation: "landscape" }); 

        for (let i = 0; i < processedFiles.length; i++) {
            if (i > 0) doc.addPage();
            const fileData = processedFiles[i];
            const imgData = await blobToBase64(fileData.blob);
            const pageWidth = doc.internal.pageSize.getWidth();
            const pageHeight = doc.internal.pageSize.getHeight();
            doc.addImage(imgData, 'JPEG', 0, 0, pageWidth, pageHeight);
        }
        doc.save("slides_final.pdf");
        btn.disabled = false;
        btn.innerText = "ğŸ“„ ä¸‹è¼‰ PDF";
    }

    async function shareAllImages() {
        if (processedFiles.length === 0) return;
        if (navigator.share && navigator.canShare) {
            const filesArray = processedFiles.map(f => 
                new File([f.blob], f.name, { type: "image/jpeg" })
            );
            try {
                await navigator.share({
                    files: filesArray,
                    title: 'æŠ•å½±ç‰‡è™•ç†çµæœ',
                    text: 'é€™æ˜¯è™•ç†å¥½çš„æŠ•å½±ç‰‡'
                });
            } catch (error) {
                console.log('åˆ†äº«å–æ¶ˆæˆ–å¤±æ•—', error);
            }
        } else {
            alert("æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´æ‰¹æ¬¡åˆ†äº«åŠŸèƒ½");
        }
    }

    function blobToBase64(blob) {
        return new Promise((resolve, _) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.readAsDataURL(blob);
        });
    }
</script>
</body>
</html>
