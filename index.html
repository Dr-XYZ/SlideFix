<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æŠ•å½±ç‰‡ç¥å™¨ (PDF/æ‰¹é‡è¼¸å‡º)</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; max-width: 800px; margin: 0 auto; padding: 15px; background: #f0f2f5; color: #333; }
        .container { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        h1 { text-align: center; font-size: 1.4rem; margin-bottom: 20px; color: #2c3e50; }
        
        /* æ§åˆ¶å€ */
        .controls { text-align: center; padding: 25px; border: 2px dashed #cbd5e0; border-radius: 8px; background: #f8fafc; margin-bottom: 20px;}
        
        /* æŒ‰éˆ•ç¾¤çµ„ */
        .btn-group { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-top: 15px; }

        .btn { padding: 12px 20px; border-radius: 8px; border: none; font-size: 16px; cursor: pointer; font-weight: 500; transition: background 0.2s; text-decoration: none; display: inline-flex; align-items: center; justify-content: center; }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        
        .btn-primary { background: #3182ce; color: white; width: 100%; }
        .btn-pdf { background: #e53e3e; color: white; flex: 1; min-width: 140px; } /* ç´…è‰² PDF æŒ‰éˆ• */
        .btn-share { background: #38a169; color: white; flex: 1; min-width: 140px; } /* ç¶ è‰² åˆ†äº« æŒ‰éˆ• */

        /* é€²åº¦æ¢ */
        #progress-container { margin-bottom: 20px; display: none; }
        .progress-bar { width: 100%; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden; }
        .progress-fill { height: 100%; background: #4299e1; width: 0%; transition: width 0.3s ease; }
        #status-text { text-align: center; margin-top: 8px; font-size: 13px; color: #718096; }

        /* çµæœåˆ—è¡¨ */
        .gallery { display: flex; flex-direction: column; gap: 20px; margin-top: 20px; }
        .gallery-item { display: flex; flex-direction: column; background: white; border: 1px solid #e2e8f0; border-radius: 8px; overflow: hidden; }
        .img-wrapper { background: #000; min-height: 200px; display: flex; align-items: center; justify-content: center; }
        .gallery-item img { max-width: 100%; height: auto; display: block; }
        .item-info { padding: 10px; font-size: 14px; font-weight: bold; color: #4a5568; text-align: center; border-top: 1px solid #eee; }

        .hidden { display: none; }
        input[type="file"] { display: none; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>

<div class="container">
    <h1>ğŸ“¸ æŠ•å½±ç‰‡ç¥å™¨ (PDF/æ‰¹é‡ç‰ˆ)</h1>
    
    <div class="controls">
        <p style="margin-bottom: 15px; color: #666;">æ‰¹æ¬¡è™•ç†å¾Œï¼Œå¯è½‰å­˜ PDF æˆ–ä¸€æ¬¡åˆ†äº«</p>
        <input type="file" id="fileInput" accept="image/*" multiple disabled>
        <button class="btn btn-primary" id="selectBtn" onclick="document.getElementById('fileInput').click()" disabled>
            ğŸ“‚ é¸æ“‡ç…§ç‰‡
        </button>
        <div id="status" style="margin-top:10px; font-size: 14px; color: #888;">â³ æ­£åœ¨è¼‰å…¥æ ¸å¿ƒ...</div>

        <div id="action-buttons" class="btn-group hidden">
            <button class="btn btn-pdf" id="btnPdf" onclick="downloadPDF()">ğŸ“„ ä¸‹è¼‰ PDF</button>
            <button class="btn btn-share" id="btnShare" onclick="shareAllImages()">ğŸ“¤ å„²å­˜æ‰€æœ‰åœ–ç‰‡</button>
        </div>
    </div>

    <div id="progress-container">
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div id="status-text">æº–å‚™ä¸­...</div>
    </div>

    <div class="gallery" id="gallery"></div>
</div>

<canvas id="processCanvas" class="hidden"></canvas>
<script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady()" type="text/javascript"></script>

<script>
    let cvReady = false;
    const MAX_DIMENSION = 2000;
    const TARGET_RATIO = 4.0 / 3.0; 
    
    // ç”¨ä¾†æš«å­˜è™•ç†å¥½çš„æª”æ¡ˆ Blobï¼Œæ–¹ä¾¿æœ€å¾Œæ‰“åŒ…
    let processedFiles = []; 

    function onOpenCvReady() {
        cvReady = true;
        document.getElementById('status').innerText = "âœ… ç³»çµ±å°±ç·’";
        document.getElementById('fileInput').disabled = false;
        document.getElementById('selectBtn').disabled = false;
    }

    document.getElementById('fileInput').addEventListener('change', async (e) => {
        if (!cvReady) return;
        const files = Array.from(e.target.files);
        if (files.length === 0) return;

        // é‡ç½®
        document.getElementById('gallery').innerHTML = '';
        document.getElementById('action-buttons').classList.add('hidden');
        document.getElementById('progress-container').style.display = 'block';
        processedFiles = []; // æ¸…ç©ºæš«å­˜
        
        await processBatch(files);
    });

    async function processBatch(files) {
        const total = files.length;
        const statusText = document.getElementById('status-text');
        const progressFill = document.getElementById('progressFill');

        for (let i = 0; i < total; i++) {
            const file = files[i];
            statusText.innerText = `æ­£åœ¨è™•ç† (${i + 1}/${total}): ${file.name}`;
            progressFill.style.width = `${((i + 1) / total) * 100}%`;

            try {
                const blob = await processSingleImage(file);
                if (blob) {
                    // å­˜å…¥é™£åˆ—ï¼Œçµ¦ PDF/Share ä½¿ç”¨
                    processedFiles.push({
                        blob: blob,
                        name: `fixed_${i+1}_${file.name}`,
                        originalName: file.name
                    });
                    addResultToPage(blob, file.name);
                }
            } catch (err) {
                console.error(`Error processing ${file.name}`, err);
            }
            await new Promise(resolve => requestAnimationFrame(resolve));
        }

        statusText.innerText = "ğŸ‰ è™•ç†å®Œæˆï¼è«‹é¸æ“‡è¼¸å‡ºæ–¹å¼";
        document.getElementById('action-buttons').classList.remove('hidden');
    }

    // --- æ ¸å¿ƒå½±åƒè™•ç† (ä¿æŒä¸è®Š) ---
    function processSingleImage(file) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                try {
                    let src = cv.imread(img);
                    if (src.cols > MAX_DIMENSION || src.rows > MAX_DIMENSION) {
                        let scale = MAX_DIMENSION / Math.max(src.cols, src.rows);
                        cv.resize(src, src, new cv.Size(Math.round(src.cols * scale), Math.round(src.rows * scale)), 0, 0, cv.INTER_AREA);
                    }

                    let dst = new cv.Mat();
                    let gray = new cv.Mat();
                    let blurred = new cv.Mat();
                    let edged = new cv.Mat();
                    let dilated = new cv.Mat();
                    
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                    cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);
                    cv.Canny(blurred, edged, 50, 200);

                    let M = cv.Mat.ones(5, 5, cv.CV_8U);
                    let anchor = new cv.Point(-1, -1);
                    cv.dilate(edged, dilated, M, anchor, 2, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());

                    let contours = new cv.MatVector();
                    let hierarchy = new cv.Mat();
                    cv.findContours(dilated, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                    let maxArea = 0;
                    let bestContour = null;
                    let imageArea = src.cols * src.rows;

                    for (let i = 0; i < contours.size(); ++i) {
                        let cnt = contours.get(i);
                        let area = cv.contourArea(cnt);
                        if (area < imageArea * 0.1) continue;
                        let peri = cv.arcLength(cnt, true);
                        let approx = new cv.Mat();
                        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
                        if (approx.rows === 4) {
                            if (area > maxArea) {
                                maxArea = area;
                                if (bestContour) bestContour.delete();
                                bestContour = approx.clone();
                            }
                        }
                        approx.delete();
                    }

                    if (bestContour) {
                        warpPerspective(src, bestContour, dst);
                        bestContour.delete();
                    } else {
                        dst = src.clone(); // æ²’æŠ“åˆ°å°±ç”¨åŸåœ–ï¼Œé¿å…ç©ºç™½
                    }

                    cv.imshow('processCanvas', dst);
                    let canvas = document.getElementById('processCanvas');
                    canvas.toBlob((blob) => {
                        src.delete(); dst.delete(); gray.delete();
                        blurred.delete(); edged.delete(); dilated.delete();
                        contours.delete(); hierarchy.delete(); M.delete();
                        resolve(blob);
                    }, 'image/jpeg', 0.85); // PDF å£“ç¸®å“è³ª

                } catch (e) {
                    reject(e);
                }
            };
            img.src = URL.createObjectURL(file);
        });
    }

    function warpPerspective(src, contour, dst) {
        let pts = [];
        for (let i = 0; i < 4; i++) {
            pts.push(contour.data32S[i * 2]);
            pts.push(contour.data32S[i * 2 + 1]);
        }
        let sortedPts = orderPoints(pts);
        let tl = sortedPts[0], tr = sortedPts[1], br = sortedPts[2], bl = sortedPts[3];
        let widthA = Math.hypot(br.x - bl.x, br.y - bl.y);
        let widthB = Math.hypot(tr.x - tl.x, tr.y - tl.y);
        let maxWidth = Math.max(widthA, widthB);
        let finalWidth = maxWidth;
        let finalHeight = Math.floor(finalWidth / TARGET_RATIO);
        let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [tl.x, tl.y, tr.x, tr.y, br.x, br.y, bl.x, bl.y]);
        let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, finalWidth, 0, finalWidth, finalHeight, 0, finalHeight]);
        let transformM = cv.getPerspectiveTransform(srcTri, dstTri);
        cv.warpPerspective(src, dst, transformM, new cv.Size(finalWidth, finalHeight), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
        srcTri.delete(); dstTri.delete(); transformM.delete();
    }

    function orderPoints(pts) {
        let points = [{x: pts[0], y: pts[1]}, {x: pts[2], y: pts[3]}, {x: pts[4], y: pts[5]}, {x: pts[6], y: pts[7]}];
        points.sort((a, b) => (a.x + a.y) - (b.x + b.y));
        let tl = points[0], br = points[3];
        let remaining = [points[1], points[2]];
        remaining.sort((a, b) => (a.y - a.x) - (b.y - b.x));
        return [tl, remaining[0], br, remaining[1]];
    }

    function addResultToPage(blob, originalName) {
        const url = URL.createObjectURL(blob);
        const div = document.createElement('div');
        div.className = 'gallery-item';
        div.innerHTML = `
            <div class="img-wrapper"><img src="${url}"></div>
            <div class="item-info">å·²è™•ç†: ${originalName}</div>
        `;
        document.getElementById('gallery').appendChild(div);
    }

    // --- æ–°åŠŸèƒ½ï¼šä¸‹è¼‰ PDF ---
    async function downloadPDF() {
        if (processedFiles.length === 0) return;
        const btn = document.getElementById('btnPdf');
        btn.disabled = true;
        btn.innerText = "æ­£åœ¨è£½ä½œ PDF...";

        const { jsPDF } = window.jspdf;
        // å»ºç«‹ PDFï¼Œé è¨­ A4
        const doc = new jsPDF({ orientation: "landscape" }); 

        for (let i = 0; i < processedFiles.length; i++) {
            if (i > 0) doc.addPage(); // ç¬¬ä¸€é ä¸ç”¨åŠ 
            
            const fileData = processedFiles[i];
            const imgData = await blobToBase64(fileData.blob);
            
            // è¨ˆç®—æ¯”ä¾‹å¡«æ»¿é é¢
            const pageWidth = doc.internal.pageSize.getWidth();
            const pageHeight = doc.internal.pageSize.getHeight();
            doc.addImage(imgData, 'JPEG', 0, 0, pageWidth, pageHeight);
        }

        doc.save("slides_fixed.pdf");
        btn.disabled = false;
        btn.innerText = "ğŸ“„ ä¸‹è¼‰ PDF";
    }

    // --- æ–°åŠŸèƒ½ï¼šæ‰¹æ¬¡åˆ†äº« (ä¸ç”¨ ZIP) ---
    async function shareAllImages() {
        if (processedFiles.length === 0) return;
        
        // æª¢æŸ¥ç€è¦½å™¨æ˜¯å¦æ”¯æ´ Web Share API Level 2 (æ”¯æ´æª”æ¡ˆåˆ†äº«)
        if (navigator.share && navigator.canShare) {
            
            // å°‡ Blob è½‰å› File ç‰©ä»¶
            const filesArray = processedFiles.map(f => 
                new File([f.blob], f.name, { type: "image/jpeg" })
            );

            try {
                // ä¸€æ¬¡åˆ†äº«æ‰€æœ‰æª”æ¡ˆ
                await navigator.share({
                    files: filesArray,
                    title: 'æŠ•å½±ç‰‡è™•ç†çµæœ',
                    text: 'é€™æ˜¯è™•ç†å¥½çš„æŠ•å½±ç‰‡'
                });
            } catch (error) {
                console.log('åˆ†äº«å–æ¶ˆæˆ–å¤±æ•—', error);
            }
        } else {
            alert("æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´æ‰¹æ¬¡åˆ†äº«åŠŸèƒ½ (iOS è«‹ä½¿ç”¨ Safari)");
        }
    }

    function blobToBase64(blob) {
        return new Promise((resolve, _) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.readAsDataURL(blob);
        });
    }

</script>
</body>
</html>
